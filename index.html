<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="babylon.objFileLoader.min.js"></script>
    </head>
   <body>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <script>
        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = async function () 
        {
            const scene = new BABYLON.Scene(engine);  
            let head = null;
            let camera = null;
            await Ammo();
            scene.enablePhysics(new BABYLON.Vector3(0, 9, 0), new BABYLON.AmmoJSPlugin());

            BABYLON.SceneLoader.ImportMesh("", "/assets/", "head.obj", scene, function (meshes) 
            {
                // head.forceSharedVertices();

                // var softBoxOptions = {
                //     mass: 15,
                //     friction: 0.9,
                //     restitution: 0.3,
                //     pressure: 2,
                //     velocityIterations: 10, 
                //     positionIterations: 10,
                //     stiffness: 1,
                //     damping: 0.1
                // }

                // head.physicsImpostor = new BABYLON.PhysicsImpostor(head, BABYLON.PhysicsImpostor.SoftbodyImpostor, softBoxOptions, scene);

                head = meshes[0];
                head.checkCollisions = true;
                head.material = new BABYLON.StandardMaterial("headMat", scene);
                head.material.diffuseColor = new BABYLON.Color3(1, 0, 0);
                head.physicsImpostor = new BABYLON.PhysicsImpostor(head, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, restitution: 0.9}, scene);

                let floor = BABYLON.Mesh.CreateBox("floor", 1, scene);
                floor.scaling = new BABYLON.Vector3(10,1,10);
                floor.physicsImpostor = new BABYLON.PhysicsImpostor(floor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9}, scene);

                let distanceJoint = new BABYLON.DistanceJoint({ maxDistance: -0.2, collision:false });
                floor.physicsImpostor.addJoint(head.physicsImpostor, distanceJoint);

                // friction
                scene.onBeforeRenderObservable.add(function()
                {
                    head.physicsImpostor.setAngularVelocity(head.physicsImpostor.getAngularVelocity().scale(.99));
                });
            });

            camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2.5, 4, new BABYLON.Vector3(0, 1, 0));
            // camera.attachControl(canvas, true);

            const light = new BABYLON.HemisphericLight("light", new BABYLON.Vector3(1, 1, 0));
            light.intensity = 0.7;

            scene.onPointerObservable.add((pointerInfo) => 
            {
                switch (pointerInfo.type) 
                {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                    {
                        // let normal = pointerInfo.pickInfo.getNormal();
                        let normal = pointerInfo.pickInfo.pickedMesh.getFacetNormal(pointerInfo.pickInfo.faceId);
                        
                        // let camDirection = pointerInfo.pickInfo.ray.direction;
                        // var rotation = BABYLON.Quaternion.RotationAxis(BABYLON.Vector3.Up(), 3.12/2 );
                        // camDirection.rotateByQuaternionToRef(rotation, camDirection);

                        if (head && normal)
                        {
                            const slapForce = -1.5;
                            head.physicsImpostor.applyImpulse(new BABYLON.Vector3(normal.x * slapForce, normal.y * slapForce, normal.z * slapForce), head.getAbsolutePosition());
                        }

                        break;
                    }
                }
            });

            let lines = null;
            
            // mouse move
            document.addEventListener("pointermove", function () {
                
                if (lines)
                {
                    lines.dispose();
                }

                var pickResult = scene.pick(scene.pointerX, scene.pointerY);
                
                if (pickResult.hit)
                {
                    const normal = pickResult.getNormal();
                    let position = pickResult.pickedPoint;
                    
                    let directionPosition = new BABYLON.Vector3(position.x + normal.x, position.y + normal.y, position.z + normal.z);

                    var points = [position, directionPosition];
                    lines = BABYLON.MeshBuilder.CreateLines("lines", {points:points, updatable:true}, scene);
                    lines.isPickable = false;
                }
            });

            return scene;
        };

        createScene().then(scene => {
            engine.runRenderLoop(function () 
            {
                scene.render();
            });
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });

    </script>
   </body>
</html>