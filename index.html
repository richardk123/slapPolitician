<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            #fps {
                position: absolute;
                background-color: black;
                border: 2px solid red;
                text-align: center;
                font-size: 16px;
                color: white;
                top: 15px;
                right: 10px;
                width: 60px;
                height: 20px;
            }
        </style>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="babylon.objFileLoader.min.js"></script>
    </head>
   <body>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <script>
        
        function createPunchEffect(scene, position)
        {
            // Create a particle system
            var particleSystem = new BABYLON.ParticleSystem("particles", 1000, scene);

            //Texture of each particle
            particleSystem.particleTexture = new BABYLON.Texture("textures/flare.png", scene);

            // Where the particles come from
            particleSystem.emitter = position; // the starting location

            // Colors of all particles
            particleSystem.color1 = new BABYLON.Color4(1, 1, 0, 0.83);
            particleSystem.color2 = new BABYLON.Color4(1, .5, 0);
            particleSystem.colorDead = new BABYLON.Color4(0, 0, 0.2, 0.0);

            // Size of each particle (random between...
            particleSystem.minSize = 0.03;
            particleSystem.maxSize = 0.05;

            // Life time of each particle (random between...
            particleSystem.minLifeTime = 0.005;
            particleSystem.maxLifeTime = 0.01;

            // Emission rate
            particleSystem.emitRate = 1000;

            /******* Emission Space ********/
            particleSystem.createCylinderEmitter(0.2,0.2,1,1);

            let pos = BABYLON.Vector3.Zero();
            let count = 0
            var radius = 0.1;

            function rand() {
                var rndAngle = (Math.PI / 9) * count;
                var randX = radius * Math.sin(rndAngle);
                var randY = 0;
                var randZ = radius * Math.cos(rndAngle);
                count++
                if (count >= 18) {
                    count = 0
                }
                return [randX, randY, randZ];
            }
            particleSystem.startDirectionFunction = function(worldMatrix, directionToUpdate)
            {
                let r = rand();
                pos.set(r[0], r[1], r[2]);
                BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(pos.x,pos.y,pos.z, worldMatrix, directionToUpdate);
            }

            // Custom function to get the circle effect
            particleSystem.startPositionFunction = function(worldMatrix, positionToUpdate)
            {
                BABYLON.Vector3.TransformCoordinatesFromFloatsToRef(pos.x, pos.y, pos.z, worldMatrix, position);
            }

            // Speed
            particleSystem.minEmitPower = 1;
            particleSystem.maxEmitPower = 2;
            particleSystem.updateSpeed = 0.005;

            // Start the particle system
            particleSystem.start();

            particleSystem.targetStopDuration = 0.02;
        }

        function createSpringPath(point1, point2, point2Default, scene, springRadius, springSteps)
        {
            let path = [];
            const xStepSize = (point1.x - point2.x) / springSteps;
            const yStepSize = (point1.y - point2.y) / springSteps;
            const zStepSize = (point1.z - point2.z) / springSteps;
            
            const currentDistance = BABYLON.Vector3.Distance(point1, point2);
            const defCurrDiffX = (point2.x - point2Default.x) / springSteps;
            const defCurrDiffY = (point2.y - point2Default.y) / springSteps;
            const defCurrDiffZ = (point2.z - point2Default.z) / springSteps;
            
            // path curve
            let curve = 0;
            for (step = 0; step < springSteps; step++)
            {
                curve += (step * 1.1 ) /  springSteps;

                let x = point1.x + (defCurrDiffX * curve);
                let y = point1.y - (yStepSize * step);
                let z = point1.z + (defCurrDiffZ * curve);

                path.push(new BABYLON.Vector3(x, y, z));
            }

            // spring rotation
            let angle = 0;
            for (step = 0; step < springSteps; step++)
            {
                const radians = angle * (Math.PI / 180);
                const curvePoint = path[step];
                const nextCurvePoint = path[step + 1];

                let newPosition = new BABYLON.Vector3(curvePoint.x, curvePoint.y, curvePoint.z);

                if (nextCurvePoint)
                {

                    const directionToNext = new BABYLON.Vector3(curvePoint.x - nextCurvePoint.x, curvePoint.y - nextCurvePoint.y, curvePoint.z - nextCurvePoint.z).normalize();
                    const perpendicular1 = directionToNext.cross(new BABYLON.Vector3(1, 0, 0));
                    const perpendicular2 = directionToNext.cross(new BABYLON.Vector3(0, 0, 1));
                    
                    newPosition.x += (springRadius * Math.cos(radians) * perpendicular1.x) + (springRadius * Math.sin(radians) * perpendicular2.x);
                    newPosition.y += (springRadius * Math.cos(radians) * perpendicular1.y) + (springRadius * Math.sin(radians) * perpendicular2.y);
                    newPosition.z += (springRadius * Math.cos(radians) * perpendicular1.z) + (springRadius * Math.sin(radians) * perpendicular2.z);
                }

                path[step] = newPosition;

                angle +=40;
            }

            return path;
        }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = async function () 
        {
            const scene = new BABYLON.Scene(engine);  
            scene.createDefaultEnvironment();


            let head = null;
            var musicBox = null;

            await Ammo();
            
            scene.clearColor = new BABYLON.Color3(0, 0, 0);
            scene.debugLayer.show(); // debug
            scene.shadowsEnabled = true;
            scene.enablePhysics(new BABYLON.Vector3(0, 0, 0), new BABYLON.AmmoJSPlugin()); // gravity up

            // camera
            const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2, 3, new BABYLON.Vector3(0, 1, 0));
            camera.setPosition(new BABYLON.Vector3(0, 6, 6));
            camera.attachControl(canvas, true);  // rotate with mouse down

            // light
            const light = new BABYLON.SpotLight("light", new BABYLON.Vector3(0, 7, 2), new BABYLON.Vector3(0, -1, -0.3), Math.PI / 3, 5, scene);
            light.light = 10;
            light.range = 250;
            light.shadowMinZ = 0.1;
            light.shadowMaxZ = 6;
            light.intensity = 0.5;
            
            let shadowGenerator = new BABYLON.ShadowGenerator(1024, light);
            shadowGenerator.useBlurCloseExponentialShadowMap = true;
            shadowGenerator.forceBackFacesOnly = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.useKernelBlur = true;

            // floor
            {
                const floorMaterial = new BABYLON.StandardMaterial("floorMaterial", scene);
                floorMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    
                const floor = BABYLON.Mesh.CreateBox("floor", 1, scene);
                floor.collision = false;
                floor.scaling = new BABYLON.Vector3(100, 1, 100);
                floor.material = floorMaterial;
                shadowGenerator.getShadowMap().renderList.push(floor);
                floor.receiveShadows = true;
            }

            // glove
            const glove = BABYLON.MeshBuilder.CreateSphere("glove", {diameter: 0.2}, scene);

            shadowGenerator.getShadowMap().renderList.push(glove);
            glove.receiveShadows = true;
            glove.isVisible = true;

            const gloveMaterial = new BABYLON.StandardMaterial("gloveMaterial", scene);
            gloveMaterial.emissiveColor = new BABYLON.Color3(1, 0, 0);
            glove.material = gloveMaterial;

            glove.physicsImpostor = new BABYLON.PhysicsImpostor(glove, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.5, restitution: 0.9 }, scene);
            glove.setEnabled(true);

            // glove
            // let glove = null;
            // BABYLON.SceneLoader.ImportMesh(null, "./assets/", "glove2.glb", scene, function (meshes) 
            // {
            //     glove = meshes[0];

            //     glove.scaling.x = 0.03;
            //     glove.scaling.y = 0.03;
            //     glove.scaling.z = 0.03;

            //     glove.position.x = 1;
            //     glove.position.y = 1;
            //     glove.position.z = 0;

            //     shadowGenerator.getShadowMap().renderList.push(glove);
            //     glove.receiveShadows = true;
            //     glove.isVisible = true;

            //     glove.physicsImpostor = new BABYLON.PhysicsImpostor(glove, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.5, restitution: 0.9 }, scene);
            //     glove.setEnabled(false);
            // });

            // music box
            {
                musicBox = BABYLON.Mesh.CreateBox("1", 1, scene);
                musicBox.collision = false;
                musicBox.position = new BABYLON.Vector3(0, 1.1, 0);
                musicBox.physicsImpostor = new BABYLON.PhysicsImpostor(musicBox, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);
                shadowGenerator.getShadowMap().renderList.push(musicBox);
                musicBox.receiveShadows = true;
            }

            // head
            {
                head = BABYLON.MeshBuilder.CreateSphere("sphere", {diameter: 1}, scene);
                head.position = new BABYLON.Vector3(0, 2, 0);
                head.physicsImpostor = new BABYLON.PhysicsImpostor(head, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9 }, scene);
                
                // self shadow
                shadowGenerator.getShadowMap().renderList.push(head);
                head.receiveShadows = true;
            }

            let springMesh = null;
            scene.executeWhenReady(() =>
            {
                // create spring
                let distanceJoint = new BABYLON.DistanceJoint({ maxDistance: -2, collision: false});
                musicBox.physicsImpostor.addJoint(head.physicsImpostor, distanceJoint);

                // render spring and do a friction
                scene.onBeforeRenderObservable.add(() =>
                {
                    const springPath = createSpringPath(musicBox.getAbsolutePosition(), head.getAbsolutePosition(), new BABYLON.Vector3(0, 3.1, 0), scene, 0.1, 200);

                    if (springMesh)
                    {
                        springMesh = BABYLON.MeshBuilder.CreateTube("spring", {path: springPath, instance: springMesh} );
                    } 
                    else if (musicBox && head)
                    {
                        springMesh = BABYLON.MeshBuilder.CreateTube("spring", 
                                                 {path: springPath, radius: 0.01, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true, tessellation : 3}, 
                                                 scene);
                        springMesh.collision = false;
                    }
                });

                //on physics update
                scene.onBeforePhysicsObservable.add(() =>
                {
                    if (head)
                    {
                        // apply gravity only for head
                        head.physicsImpostor.applyForce(new BABYLON.Vector3(0, 9, 0), head.getAbsolutePosition());

                        // spring friction
                        let reducedVelocity = head.physicsImpostor.getAngularVelocity().scale(.97);
                        head.physicsImpostor.setAngularVelocity(reducedVelocity);
                    }
                });
            });


            // mouse click
            scene.onPointerObservable.add((pointerInfo) => 
            {
                switch (pointerInfo.type) 
                {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                    {
                        const pickInfo = pointerInfo.pickInfo;

                        if (pickInfo.hit && pickInfo.pickedMesh === head)
                        {

                            const normal = pickInfo.pickedMesh.getFacetNormal(pickInfo.faceId);
                            const slapForce = -4;
                            const punchForce = new BABYLON.Vector3(normal.x * slapForce, normal.y * slapForce, normal.z * slapForce);
                            const hitPoint = pickInfo.pickedPoint;

                            const gloveDistance = 0.5;
                            
                            glove.setEnabled(true);
                            glove.position.x = hitPoint.x + (normal.x * gloveDistance);
                            glove.position.y = hitPoint.y + (normal.y * gloveDistance);
                            glove.position.z = hitPoint.z + (normal.z * gloveDistance);
                            glove.lookAt(hitPoint);
                            glove.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                            glove.physicsImpostor.applyImpulse(punchForce.scale(0.5), glove.getAbsolutePosition());

                            // head.physicsImpostor.applyImpulse(punchForce, head.getAbsolutePosition());

                            // createPunchEffect(scene, hitPoint);
                            
                            setTimeout(() =>
                            {
                                glove.setEnabled(false);
                            }, 200);
                        }

                        break;
                    }
                }
            });

            return scene;
        };

        createScene().then(scene => {
            engine.runRenderLoop(function () 
            {
                scene.render();
            });
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });

    </script>
   </body>
</html>