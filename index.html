<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
            
            #progressBar {
                position: fixed;
                left: 50%;
                bottom: 10px;
                width: 200px;
                height: 30px;
                border: 1px solid darkgreen;
                border-radius: 5px;
                background-color: black;
                transform: translate(-50%, -50%);
            }
            #status
            {
                background-color: green;
                height: 100%;
                width: 0%;
                color: silver;
                text-align: center;
                vertical-align: middle;
                line-height: 30px;
            }
            #debth
            {
                color: red;
                position: fixed;
                top: 20px;
                right: 20px;
                font-weight: bold;
            }
        </style>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
    </head>
   <body>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <div id="debth"></div>
    <div id="progressBar">
        <div id="status"></div>
    </div>
    <script>

        let debth =  -2208636516783;
        const reloadTime = 30;
        let ballShootTime = reloadTime;
        let pauseShitTalk = false;

        var formatter = new Intl.NumberFormat('cs-CZ', {
            style: 'currency',
            currency: 'CZK',
        });

        setInterval(() =>
        {
            if (ballShootTime < reloadTime)
            {
                ballShootTime++;
                document.getElementById("status").textContent = "Nabijim!";
            }
            else
            {
                document.getElementById("status").textContent = "Nabito!";
            }
            document.getElementById("status").style.width = (ballShootTime / reloadTime) * 100 + "%";
            document.getElementById("debth").textContent = formatter.format(debth);
        }, 100);

        function canShootBall()
        {
            return ballShootTime >= reloadTime;
        }

        function loadOffensiveTalk(files, scene)
        {
            let sounds = [];
            files.forEach(file =>
            {
                var sound = new BABYLON.Sound(file, "./audio/" + file, scene, () => 
                {
                    sounds.push(sound);
                });
            });

            return sounds;
        }

        function playRandomSound(sounds)
        {
            const randIndex = Math.floor(Math.random() * sounds.length);
            sounds[randIndex].play();
        }

        function loadShitTalk(files, scene)
        {
            let sounds = [];
            files.forEach(file =>
            {
                var sound = new BABYLON.Sound(file, "./audio/" + file, scene, () => 
                {
                    sounds.push(sound);
                });
            });

            // play every 2 seconds random shit
            setInterval(() => 
            {
                const playing = sounds.filter(s =>
                {
                    return s.isPlaying;
                }).length > 0;

                const ready = sounds.filter(s =>
                {
                    return s.isReady();
                }).length > 0;

                if (!playing && ready && !pauseShitTalk)
                {
                    playRandomSound(sounds);
                }
            }, 2000);

            return sounds;
        }

        function createSpringPath(point1, point2, point2Default, scene, springRadius, springSteps)
        {
            let path = [];
            const xStepSize = (point1.x - point2.x) / springSteps;
            const yStepSize = (point1.y - point2.y) / springSteps;
            const zStepSize = (point1.z - point2.z) / springSteps;
            
            const currentDistance = BABYLON.Vector3.Distance(point1, point2);
            const defCurrDiffX = (point2.x - point2Default.x) / springSteps;
            const defCurrDiffY = (point2.y - point2Default.y) / springSteps;
            const defCurrDiffZ = (point2.z - point2Default.z) / springSteps;
            
            // path curve
            let curve = 0;
            for (step = 0; step < springSteps; step++)
            {
                curve += (step * 1.2 ) /  springSteps;

                let x = point1.x + (defCurrDiffX * curve);
                let y = point1.y - (yStepSize * step);
                let z = point1.z + (defCurrDiffZ * curve);

                path.push(new BABYLON.Vector3(x, y, z));
            }

            const lastDirection = path[path.length -1].subtract(path[path.length -2]).normalize();

            // spring rotation
            let angle = 0;
            for (step = 0; step < springSteps; step++)
            {
                const radians = angle * (Math.PI / 180);
                const curvePoint = path[step];
                const nextCurvePoint = path[step + 1];

                let newPosition = new BABYLON.Vector3(curvePoint.x, curvePoint.y, curvePoint.z);

                if (nextCurvePoint)
                {
                    const directionToNext = new BABYLON.Vector3(curvePoint.x - nextCurvePoint.x, curvePoint.y - nextCurvePoint.y, curvePoint.z - nextCurvePoint.z).normalize();
                    const perpendicular1 = directionToNext.cross(new BABYLON.Vector3(1, 0, 0));
                    const perpendicular2 = directionToNext.cross(new BABYLON.Vector3(0, 0, 1));
                    
                    newPosition.x += (springRadius * Math.cos(radians) * perpendicular1.x) + (springRadius * Math.sin(radians) * perpendicular2.x);
                    newPosition.y += (springRadius * Math.cos(radians) * perpendicular1.y) + (springRadius * Math.sin(radians) * perpendicular2.y);
                    newPosition.z += (springRadius * Math.cos(radians) * perpendicular1.z) + (springRadius * Math.sin(radians) * perpendicular2.z);
                }

                path[step] = newPosition;

                angle +=40;
            }

            return {path: path, lastDirection: lastDirection};
        }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = async function () 
        {
            const scene = new BABYLON.Scene(engine);  
            await Ammo();
            
            scene.clearColor = new BABYLON.Color3(0, 0, 0);
            scene.ambientColor = new BABYLON.Color3(1, 1, 1);
            // scene.debugLayer.show(); // debug
            scene.enablePhysics(new BABYLON.Vector3(0, 0, 0), new BABYLON.AmmoJSPlugin()); // gravity up

            // camera
            const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2, 3, new BABYLON.Vector3(0, 2, 0));
            camera.setPosition(new BABYLON.Vector3(1, 3, 4));
            camera.attachControl(canvas, true);  // rotate with mouse down

            // light
            const light = new BABYLON.SpotLight("light", new BABYLON.Vector3(0, 5, 0), new BABYLON.Vector3(0, -1, -0.2), Math.PI / 3, 5, scene);
            light.light = 10;
            light.range = 250;
            light.shadowMinZ = 0.1;
            light.shadowMaxZ = 9;
            light.intensity = 0.9;
            light.diffuse = new BABYLON.Color3(1, 1, 0.9);
	        light.specular = new BABYLON.Color3(1, 1, 0.8);

            let shadowGenerator = new BABYLON.ShadowGenerator(512, light);
            shadowGenerator.useBlurCloseExponentialShadowMap = true;
            shadowGenerator.forceBackFacesOnly = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.useKernelBlur = true;

            // floor
            {
                const floorMaterial = new BABYLON.StandardMaterial("floorMaterial", scene);
                floorMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
    
                const floor = BABYLON.Mesh.CreateBox("floor", 1, scene);
                floor.scaling = new BABYLON.Vector3(100, 1, 100);
                floor.material = floorMaterial;
                shadowGenerator.getShadowMap().renderList.push(floor);
                floor.receiveShadows = true;
                floor.physicsImpostor = new BABYLON.PhysicsImpostor(floor, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9, friction: 0.5 }, scene);
            }

            // ball
            const ball = BABYLON.MeshBuilder.CreateSphere("ball", {diameter: 0.2, segments : 6}, scene);
            shadowGenerator.getShadowMap().renderList.push(ball);
            ball.receiveShadows = true;
            const ballMaterial = new BABYLON.StandardMaterial("ballMaterial", scene);
            ball.material = ballMaterial;
            ball.physicsImpostor = new BABYLON.PhysicsImpostor(ball, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 0.5, restitution: 0.9, friction: 0 }, scene);

            // music box
            var musicBox = null;
            BABYLON.SceneLoader.ImportMesh("", "./assets/", "musicbox2.glb", scene, function (meshes) 
            {
                // root
                musicBox = meshes[0];
                musicBox.position = new BABYLON.Vector3(0, 1, 0);
                musicBox.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
                musicBox.rotation = new BABYLON.Vector3(0, -Math.PI / 5, 0);
                musicBox.physicsImpostor = new BABYLON.PhysicsImpostor(musicBox, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9, friction: 0 }, scene);
                shadowGenerator.getShadowMap().renderList.push(meshes[1]);

                // model
                meshes[1].receiveShadows = true;
                meshes[1].material.ambientColor = new BABYLON.Color3(1, 1, 1);
            });

            let head = BABYLON.MeshBuilder.CreateSphere("babisCollision", {diameter: 1.18, segments : 18}, scene);
            head.position = new BABYLON.Vector3(0, 2, 0);
            head.physicsImpostor = new BABYLON.PhysicsImpostor(head, BABYLON.PhysicsImpostor.SphereImpostor, { mass: 1, restitution: 0.9, friction: 1 }, scene);
            head.visibility = 0.1;

            // babis
            let babis = null;
            BABYLON.SceneLoader.ImportMesh("", "./assets/", "babis.glb", scene, function (meshes) 
            {
                // root
                babis = meshes[0];
                babis.scaling = new BABYLON.Vector3(0.6, 0.6, 0.6);
                shadowGenerator.getShadowMap().renderList.push(meshes[1]);

                // model
                meshes[1].material.ambientColor = new BABYLON.Color3(0.3, 0.3, 0.3);
            });

            // on scene ready
            scene.executeWhenReady(() =>
            {
                let springMesh = null;

                // create spring
                let distanceJoint = new BABYLON.DistanceJoint({ maxDistance: -2, collision: false});
                musicBox.physicsImpostor.addJoint(head.physicsImpostor, distanceJoint);

                // first random movement
                head.physicsImpostor.applyImpulse(new BABYLON.Vector3(Math.random(), Math.random(), Math.random()).scale(3), head.getAbsolutePosition());

                // load sounds
                const shitTalk = loadShitTalk(["do zahrad.mp3", "plna zodpovednost.mp3", "prijmy.mp3", "program.mp3"], scene);
                const offensiveTalk = loadOffensiveTalk(["iq.mp3", "zkorumpovana pakaz.mp3", 
                "takova drzost.mp3", "neuveritelny.mp3", "soucast kampane.mp3", "proc.mp3", "nebudes me urazet.mp3"], scene);

                // register collision callback
                let collision = false;
                head.physicsImpostor.registerOnPhysicsCollide(ball.physicsImpostor, () => 
                {
                    // check only first collision
                    if (!collision)
                    {
                        shitTalk.forEach(talk => talk.stop());
                        offensiveTalk.forEach(talk => talk.stop());
                        pauseShitTalk = true;
                        playRandomSound(offensiveTalk);
                        debth++;
                    }
                    collision = true;

                    setTimeout(() =>
                    {
                        pauseShitTalk = false;
                        offensiveTalk.forEach(talk => talk.stop());
                        collision = false;
                    }, 2000);
                });

                // render spring and do a friction
                scene.onBeforeRenderObservable.add(() =>
                {
                    // hack to spring start at the bottom of h
                    const half = head.getAbsolutePosition().subtract(musicBox.getAbsolutePosition()).normalize().scale(0.6);
                    const springTargetPosition = head.getAbsolutePosition().subtract(half);

                    const springPath = createSpringPath(musicBox.getAbsolutePosition(), springTargetPosition, new BABYLON.Vector3(0, 3.1, 0), scene, 0.1, 200);

                    if (springMesh)
                    {
                        springMesh = BABYLON.MeshBuilder.CreateTube("spring", {path: springPath.path, instance: springMesh} );
                    } 
                    else
                    {
                        springMesh = BABYLON.MeshBuilder.CreateTube("spring", 
                                                 {path: springPath.path, radius: 0.01, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true, tessellation : 3}, 
                                                 scene);
                    }

                    // babis
                    if (babis && head)
                    {
                        babis.position = springPath.path[springPath.path.length - 1];
                        const direction = head.position.subtract(babis.position);
                        const perpendicularX = direction.cross(new BABYLON.Vector3(1, 0, 0));

                        let axis1, axis2, axis3;
                        axis1 = direction;
                        axis3 = perpendicularX;
                        axis2 = BABYLON.Vector3.Cross(axis3, axis1);

                        babis.rotation = BABYLON.Vector3.RotationFromAxis(axis1, axis2, axis3);
                        // babis.rotation = new BABYLON.Vector3(-babis.rotation.x, -babis.rotation.y - Math.PI / 2, babis.rotation.z + Math.PI / 2);
                    }
                });

                //on physics update
                scene.onBeforePhysicsObservable.add(() =>
                {
                    if (head)
                    {
                        // apply gravity only for head
                        head.physicsImpostor.applyForce(new BABYLON.Vector3(0, 9, 0), head.getAbsolutePosition());

                        // apply gravity for ball
                        ball.physicsImpostor.applyForce(new BABYLON.Vector3(0, -4, 0), head.getAbsolutePosition());

                        // spring friction
                        let reducedVelocity = head.physicsImpostor.getAngularVelocity().scale(.995);
                        head.physicsImpostor.setAngularVelocity(reducedVelocity);
                    }
                });
            });


            // mouse click
            scene.onPointerObservable.add((pointerInfo) => 
            {
                switch (pointerInfo.type) 
                {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                    {
                        const pickInfo = pointerInfo.pickInfo;

                        if (pickInfo.hit && pickInfo.pickedMesh === head && canShootBall())
                        {
                            // reset
                            ballShootTime = 0;

                            const normal = pickInfo.pickedMesh.getFacetNormal(pickInfo.faceId);
                            const slapForce = -7;
                            const punchForce = new BABYLON.Vector3(normal.x * slapForce, normal.y * slapForce, normal.z * slapForce);
                            const hitPoint = pickInfo.pickedPoint;

                            const ballDistance = 1.5;
                            
                            ball.position.x = hitPoint.x + (normal.x * ballDistance);
                            ball.position.y = hitPoint.y + (normal.y * ballDistance);
                            ball.position.z = hitPoint.z + (normal.z * ballDistance);
                            ballMaterial.emissiveColor = new BABYLON.Color3(Math.random(), Math.random(), Math.random());
                            
                            // reset ball speed
                            ball.physicsImpostor.setLinearVelocity(new BABYLON.Vector3(0, 0, 0));
                            // shoot the ball
                            ball.physicsImpostor.applyImpulse(punchForce.scale(0.5), ball.getAbsolutePosition());
                        }

                        break;
                    }
                }
            });

            // mouse move
            document.addEventListener("pointermove", function () 
            {
                var pickInfo = scene.pick(scene.pointerX, scene.pointerY);
                
                if (pickInfo.hit && pickInfo.pickedMesh === head)
                {
                    document.body.style = "cursor: crosshair";
                }
                else
                {
                    document.body.style = "cursor: auto";
                }
            });

            return scene;
        };

        createScene().then(scene => {
            engine.runRenderLoop(function () 
            {
                scene.render();
            });
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });

    </script>
   </body>
</html>