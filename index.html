<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
        <title>Babylon Template</title>
        <style>
            html, body {
                overflow: hidden;
                width: 100%;
                height: 100%;
                margin: 0;
                padding: 0;
            }
            #renderCanvas {
                width: 100%;
                height: 100%;
                touch-action: none;
            }
        </style>
        <script src="https://preview.babylonjs.com/ammo.js"></script>
        <script src="https://cdn.babylonjs.com/babylon.js"></script>
        <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="https://code.jquery.com/pep/0.4.3/pep.js"></script>
        <script src="https://preview.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
        <script src="babylon.objFileLoader.min.js"></script>
    </head>
   <body>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <script>
        
        function createSpring(point1, point2, scene, springRadius, springSteps)
        {
            let path = [];
            let xStepSize = point1.x - point2.x / springSteps;
            let yStepSize = Math.abs(point1.y - point2.y) / springSteps;
            let zStepSize = point1.z - point2.z / springSteps;
            let angle = 0;

            for (step = 0; step < springSteps; step++)
            {
                const radians = angle * (Math.PI/180);
                const x = point1.x + (xStepSize * step) + Math.sin(radians) * springRadius;
                const y = point1.y + (yStepSize * step);
                const z = point1.z + (zStepSize * step) + Math.cos(radians) * springRadius;

                angle +=40;

                path.push(new BABYLON.Vector3(x, y, z));
            }

            const spring = BABYLON.MeshBuilder.CreateTube(null, {path: path, radius: 0.005, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true}, scene);
            spring.collision = false;
            return spring;
        }

        const canvas = document.getElementById("renderCanvas");
        const engine = new BABYLON.Engine(canvas, true);

        const createScene = async function () 
        {
            const scene = new BABYLON.Scene(engine);  

            let head = null;
            var musicBox = null;

            await Ammo();
            
            scene.clearColor = new BABYLON.Color3(0, 0, 0);
            scene.debugLayer.show(); // debug
            scene.shadowsEnabled = true;
            scene.enablePhysics(new BABYLON.Vector3(0, -9, 0), new BABYLON.AmmoJSPlugin()); // gravity up

            // camera
            const camera = new BABYLON.ArcRotateCamera("camera", Math.PI / 2, Math.PI / 2, 3, new BABYLON.Vector3(0, 0, -3.65));
            camera.setPosition(new BABYLON.Vector3(0, 2, 2));
            // camera.attachControl(canvas, true);  // rotate with mouse down

            // light
            const light = new BABYLON.SpotLight("light", new BABYLON.Vector3(0, 4, 0.3), new BABYLON.Vector3(0, -1, 0.2), Math.PI / 3, 5, scene);
            light.light = 10;
            light.range = 25;
            light.shadowMinZ = 0.1;
            light.shadowMaxZ = 6;
            light.intensity = 0.5;
            
            let shadowGenerator = new BABYLON.ShadowGenerator(4024, light);
            shadowGenerator.useBlurCloseExponentialShadowMap = true;
            shadowGenerator.forceBackFacesOnly = true;
            shadowGenerator.blurKernel = 32;
            shadowGenerator.useKernelBlur = true;

            // floor
            let floorMaterial = new BABYLON.StandardMaterial("floorMaterial", scene);
            floorMaterial.specularColor = new BABYLON.Color3(0, 0, 0);

            let floor = BABYLON.Mesh.CreateBox("floor", 1, scene);
            floor.collision = false;
            floor.scaling = new BABYLON.Vector3(10, 1, 10);
            floor.material = floorMaterial;
            shadowGenerator.getShadowMap().renderList.push(floor);
            floor.receiveShadows = true;

            // head
            BABYLON.SceneLoader.ImportMesh(null, "./assets/", "head.obj", scene, function (meshes) 
            {
                head = meshes[0];
                head.collision = false;
                head.position = new BABYLON.Vector3(0, 1, 0);
                
                // self shadow
                shadowGenerator.getShadowMap().renderList.push(head);
                head.receiveShadows = true;

            });

            // music box
            BABYLON.SceneLoader.ImportMesh(null, "./assets/", "box.obj", scene, function (meshes) 
            {
                musicBox = meshes[0];
                musicBox.collision = false;
                musicBox.position = new BABYLON.Vector3(0, 0.7, 0);
                musicBox.scaling = new BABYLON.Vector3(0.2, 0.2, 0.2);
                musicBox.rotation = new BABYLON.Vector3(0, -Math.PI / 3, 0);

                var musicBoxMaterial = new BABYLON.StandardMaterial("musicBoxMaterial", scene);
                musicBoxMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                musicBox.material = musicBoxMaterial;

                shadowGenerator.getShadowMap().renderList.push(musicBox);
                musicBox.receiveShadows = true;
            });

            let springMesh = null;
            scene.executeWhenReady(() =>
            {
                // create spring
                head.physicsImpostor = new BABYLON.PhysicsImpostor(head, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 1, restitution: 0.9 }, scene);
                musicBox.physicsImpostor = new BABYLON.PhysicsImpostor(musicBox, BABYLON.PhysicsImpostor.BoxImpostor, { mass: 0, restitution: 0.9 }, scene);

                let distanceJoint = new BABYLON.DistanceJoint({ maxDistance: 1, collision: false});
                musicBox.physicsImpostor.addJoint(head.physicsImpostor, distanceJoint);

                scene.onBeforeRenderObservable.add(function()
                {
                    if (springMesh)
                    {
                        springMesh.dispose();
                    }
                    if (musicBox && head)
                    {
                        springMesh = createSpring(musicBox.getAbsolutePosition(), head.getAbsolutePosition(), scene, 0.02, 200);
                    }

                    // reduction
                    const reduction = .99;
                    let reducedVelocity = head.physicsImpostor.getAngularVelocity().scale(reduction);
                    head.physicsImpostor.setAngularVelocity(reducedVelocity);
                });
            });


            // mouse click
            scene.onPointerObservable.add((pointerInfo) => 
            {
                switch (pointerInfo.type) 
                {
                    case BABYLON.PointerEventTypes.POINTERDOWN:
                    {
                        const pickInfo = pointerInfo.pickInfo;

                        if (pickInfo.hit)
                        {
                            let normal = pickInfo.pickedMesh.getFacetNormal(pickInfo.faceId);
                            const slapForce = 0.8;
                            head.physicsImpostor.applyImpulse(new BABYLON.Vector3(normal.x * slapForce, normal.y * slapForce, normal.z * slapForce), head.getAbsolutePosition());
                        }

                        break;
                    }
                }
            });

            // mouse move
            let lines = null;
            document.addEventListener("pointermove", function () {
                
                if (lines)
                {
                    lines.dispose();
                }

                var pickResult = scene.pick(scene.pointerX, scene.pointerY);
                
                if (pickResult.hit)
                {
                    const normal = pickResult.getNormal();
                    let position = pickResult.pickedPoint;
                    
                    let directionPosition = new BABYLON.Vector3(position.x + normal.x, position.y + normal.y, position.z + normal.z);

                    var points = [position, directionPosition];
                    lines = BABYLON.MeshBuilder.CreateLines("lines", {points:points, updatable:true}, scene);
                    lines.isPickable = false;
                }
            });

            return scene;
        };

        createScene().then(scene => {
            engine.runRenderLoop(function () 
            {
                scene.render();
            });
        });

        window.addEventListener("resize", function () {
            engine.resize();
        });

    </script>
   </body>
</html>